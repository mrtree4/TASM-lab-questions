\chapter{Организация циклов. Массивы данных}
\begin{itemize}
\item Что называют <<массивом данных>>? Что отличает каждый <<элемент>> массива в памяти?
\item Какой способ внутрисегментной адресации можно использовать, чтобы организовать цикл действий над массивом данных в памяти?
\item Какие регистры можно использовать для задания адреса в этих способах адресации?
\item Какой командой можно занести в регистр:
    \begin{itemize}
    \item символический внутрисегментный адрес;
    \item числовое значение адреса?
    \end{itemize}
\item Как выполняется команда LOOP? Какой регистр используется ею в качестве вычитающего счётчика циклов?
\item Можно ли организовать цикл без использования команды LOOP?
\end{itemize}

\section{Что называют <<массивом данных>>? Что отличает каждый <<элемент>> массива в памяти?}

Массив данных — это упорядоченная совокупность однотипных элементов, размещённых в памяти подряд, без промежутков, и имеющих общее имя (метку). Каждый элемент массива имеет одинаковый размер (1, 2, 4 или больше байт), а различие между ними определяется их смещением относительно начала массива.

В языке ассемблера TASM массивы определяются с помощью директив резервирования памяти, таких как DB (define byte), DW (define word), DD (define double word) и т. д.
Особенности элементов массива заключаются в том, что каждый из них:

-Имеет уникальный адрес в памяти, который вычисляется как:Адрес_элемента = Базовый_адрес_массива + Смещение.
-Обладает фиксированным размером, одинаковым для всех элементов массива.
-Может быть доступен по индексу, который отражает его позицию в массиве.

Таким образом, отличие каждого элемента массива заключается в его смещении от начала массива, то есть в разнице адресов. При последовательной обработке массива процессор увеличивает указатель (индекс) на размер одного элемента и таким образом переходит к следующему элементу.

Массивы — основа для организации циклов, таблиц, строк и структур данных в ассемблерных программах. Они обеспечивают удобный способ хранения и последовательной обработки однотипных данных, например, при работе с текстом, числами, кодами или управляющими таблицами.

\section{Какой способ внутрисегментной адресации можно использовать, чтобы организовать цикл действий над массивом данных в памяти?}

Для организации циклов обработки массивов в памяти используется косвенная адресация (indirect addressing). Её суть заключается в том, что в регистре хранится не само значение данных, а адрес элемента массива, по которому нужно произвести операцию.
Например, если нужно последовательно обработать массив байтов, можно использовать команду:

MOV AL, [BX]

Здесь процессор интерпретирует содержимое регистра BX как адрес элемента массива внутри сегмента данных (DS).

Чтобы перейти к следующему элементу массива, достаточно изменить значение BX — увеличить его на размер элемента. Таким образом, при повторении цикла значение BX автоматически «указует» на следующий элемент массива.
Помимо простой косвенной адресации, часто применяется индексная адресация — когда адрес вычисляется как сумма базового адреса и индекса элемента:

MOV AL, [BX+SI]
или
MOV AX, [BP+DI]

Этот способ особенно удобен при работе с двухмерными массивами, таблицами структур или при параллельной обработке данных.

Таким образом, основной способ внутрисегментной адресации для организации циклов над массивами — косвенный и индексный, поскольку они позволяют изменять адрес каждого элемента во время выполнения программы и эффективно обходить массив в цикле.

\section{Какие регистры можно использовать для задания адреса в этих способах адресации?}

В архитектуре процессора x86 существует несколько адресных регистров, специально предназначенных для работы с памятью. Они могут использоваться по отдельности или в сочетании для различных способов адресации.

Для внутрисегментной адресации применяются следующие регистры:

BX (Base Register) — базовый регистр данных. Чаще всего используется для указания начала массива.

BP (Base Pointer) — базовый указатель стека или структур данных, часто используется вместе с сегментом SS.

SI (Source Index) — индексный регистр источника, применяется для чтения данных из массива.

DI (Destination Index) — индексный регистр при записи или обработке данных.

Для операций над массивами в сегменте данных (DS) обычно используются BX, SI, DI. При этом возможны различные комбинации:

MOV AL, [BX]         ; косвенная адресация
MOV AL, [BX+SI]      ; базово-индексная адресация
MOV AL, [SI+5]       ; индексная адресация со смещением

Все эти регистры обеспечивают гибкую адресацию, позволяя задавать не только текущее положение в массиве, но и шаг перехода между элементами.

Таким образом, для задания адреса при работе с массивами применяются регистры BX, BP, SI, DI, которые могут использоваться как отдельно, так и в комбинациях, образуя различные режимы внутрисегментной адресации.

\section{Какой командой можно занести в регистр}

Для занесения символического внутрисегментного адреса (то есть адреса, заданного через метку в программе) используется команда LEA (Load Effective Address). Она загружает в регистр вычисленный адрес (смещение) операнда, не обращаясь к самой памяти.

Например:

LEA BX, ARRAY

В результате выполнения этой команды в регистр BX будет помещено смещение начала массива ARRAY в сегменте данных, но не его содержимое. Команда LEA используется, когда нужно работать с адресами, например, для итерации по массиву или передачи указателя в подпрограмму.

Для занесения числового значения адреса используется команда MOV. Она позволяет напрямую записать константу в регистр:

MOV BX, 0020h
В этом случае в BX будет находиться просто число 0020h, которое может быть как адресом, так и обычным значением.

Таким образом:

Для символического адреса — LEA (получает адрес по имени метки);
Для числового значения — MOV (записывает константу напрямую).

\section{Как выполняется команда LOOP? Какой регистр используется ею в качестве вычитающего счётчика циклов?}

Команда LOOP — это специальная инструкция для организации циклов, которая автоматически уменьшает счётчик итераций и выполняет переход, пока счётчик не станет равным нулю.

Её синтаксис:

LOOP метка

При выполнении команда уменьшает содержимое регистра CX (в 16-битном режиме) или ECX (в 32-битном). После этого процессор проверяет значение регистра:

если оно не равно нулю, выполняется переход по указанной метке;

если равно нулю — выполнение продолжается со следующей команды.

Пример:

MOV CX, 5
M1:  ADD AL, [BX]
     INC BX
     LOOP M1

Здесь команда LOOP создаёт цикл, который выполняется 5 раз. Каждый раз CX уменьшается на 1.

Команда LOOP удобна своей простотой — она объединяет в себе уменьшение счётчика и проверку условия. Однако, в отличие от условных переходов, она не анализирует флаги, а работает только с CX/ECX.

Таким образом, регистр CX (или ECX) используется как счётчик циклов, а команда LOOP автоматически организует повторение блока команд заданное количество раз.

\section{Можно ли организовать цикл без использования команды LOOP?}

Да, цикл в языке ассемблера можно организовать без использования команды LOOP, применяя обычные команды сравнения (CMP) и условные переходы (Jxx). Такой способ более гибкий, поскольку позволяет задавать любые условия выхода из цикла, а не только зависимость от CX.

Пример цикла без LOOP:

MOV CX, 5
M1:  ADD AL, [BX]
     INC BX
     DEC CX
     JNZ M1

Здесь команда DEC CX уменьшает счётчик вручную, а JNZ (Jump if Not Zero) выполняет переход, пока CX не станет равным нулю. По сути, это аналог команды LOOP, но реализованный через общие инструкции.

Такой подход имеет несколько преимуществ:

можно использовать любой регистр в качестве счётчика;

можно задать сложные условия выхода (например, по флагу ZF, SF и др.);

цикл можно сделать вложенным или зависимым от данных, а не от фиксированного числа итераций.

Таким образом, команда LOOP — удобный инструмент для простых циклов, но далеко не единственный. Практически любой цикл в ассемблере можно построить с помощью комбинации CMP + условного перехода, что делает программную логику более гибкой и универсальной.

\endinput
