\chapter{Разветвления}
\begin{itemize}
\item Чем похожи команды вычитания SUB и сравнения CMP?
\item Почему используются разные команды условного перехода после сравнения знаковых и беззнаковых чисел?
\item В командах прямых внутрисегментных переходов расстояние перехода отсчитывается от \dots ?
\item Каково различие между длинным и коротким прямым переходом?
\end{itemize}

\section{ем похожи команды вычитания SUB и сравнения CMP?}

Команды SUB (Subtract) и CMP (Compare) в языке ассемблера TASM имеют много общего, поскольку обе основаны на одной и той же арифметической операции — вычитании. В обоих случаях процессор вычисляет разность между двумя операндами, однако различие между ними заключается в том, куда помещается результат и для чего используется команда.

Команда SUB выполняет арифметическую операцию вычитания:
Операнд1 ← Операнд1 − Операнд2.
Результат сохраняется в первом операнде, а также обновляются все основные флаги процессора: флаг переноса (CF), знака (SF), нуля (ZF), переполнения (OF), паритета (PF) и вспомогательный флаг (AF). Эта команда изменяет данные, поскольку её цель — выполнить реальное вычисление.

Команда CMP, напротив, предназначена исключительно для сравнения двух значений. Она выполняет ту же арифметическую операцию вычитания, но не сохраняет результат — он используется только для обновления флагов процессора. По сути, CMP можно рассматривать как “SUB без записи результата”.

После выполнения CMP процессор анализирует флаги, чтобы определить, какое из чисел больше, меньше или равно другому. Например:

если ZF = 1, значит, операнды равны;

если CF = 1, значит, первое число меньше второго (для беззнаковых чисел);

если SF ≠ OF, значит, первое число меньше второго (для знаковых чисел).

Таким образом, CMP используется вместе с командами условных переходов (JE, JNE, JA, JB, JG, JL и др.), которые интерпретируют состояние флагов и определяют, выполнять ли переход.

Обе команды тесно связаны: CMP — это «чистое» сравнение без изменения данных, а SUB — реальное вычитание. Поэтому на уровне микрокода они работают одинаково, но с разной целью. Такое разделение позволяет ассемблеру быть более гибким: SUB используют для вычислений, CMP — для принятия решений и ветвлений программы.

\section{Почему используются разные команды условного перехода после сравнения знаковых и беззнаковых чисел?}

В архитектуре процессора x86 различаются два типа чисел — знаковые и беззнаковые, и это различие напрямую влияет на интерпретацию результатов сравнения. Дело в том, что знаковое число хранится в дополнительном коде, где старший бит (бит 7 в байте, бит 15 в слове) служит признаком знака: 0 — положительное, 1 — отрицательное.

Из-за этого два одинаковых двоичных значения могут иметь совершенно разный смысл. Например, байт 10000000b — это 128 в беззнаковом представлении и −128 в знаковом. Поэтому процессор должен по-разному трактовать результаты вычитания в зависимости от того, как разработчик рассматривает данные.

После выполнения команды CMP флаги процессора (CF, ZF, SF, OF) изменяются одинаково, но значение этих флагов нужно интерпретировать по-разному для знаковых и беззнаковых чисел:

Для беззнаковых чисел основным является флаг переноса (CF), который показывает, был ли «заём». Если CF = 1, значит, первое число меньше второго.
Поэтому для беззнаковых сравнений используются команды:

JA (Jump Above) — переход, если больше (CF = 0 и ZF = 0);

JB (Jump Below) — переход, если меньше (CF = 1);

JAE, JBE — варианты с равенством.

Для знаковых чисел важен не CF, а комбинация SF (Sign Flag) и OF (Overflow Flag), которые позволяют определить результат в дополнительном коде.
Используются команды:

JG (Jump Greater) — переход, если больше (ZF = 0 и SF = OF);

JL (Jump Less) — переход, если меньше (SF ≠ OF);

JGE, JLE — варианты с равенством.

Таким образом, различие в командах перехода связано не с самой операцией CMP, а с тем, как интерпретируются её результаты. Для беззнаковых чисел используется CF, для знаковых — SF и OF. Это обеспечивает корректную работу программы независимо от того, является ли число в памяти положительным или отрицательным.

\section{В командах прямых внутрисегментных переходов расстояние перехода отсчитывается от \dots ?}

В командах прямых внутрисегментных переходов (direct near jumps) расстояние перехода отсчитывается от адреса следующей за командой инструкции, то есть от точки, куда указывает счётчик команд (IP/EIP) после выборки текущей команды.

Когда процессор выполняет инструкцию перехода, он уже считает адрес следующей команды, увеличивая IP (в 16-битном режиме) или EIP (в 32-битном). Поэтому значение смещения, закодированное в переходе, прибавляется не к адресу самой команды перехода, а к адресу следующей команды.
Здесь команда JMP SHORT 0107h имеет смещение +5. Оно отсчитывается от 0102h — адреса следующей инструкции после JMP.

Такое поведение объясняется принципом относительной адресации (relative addressing), при котором переход задаётся не абсолютным адресом, а смещением относительно текущего положения. Это упрощает компоновку и загрузку программы, поскольку переход не зависит от того, где именно в памяти размещён код.

Таким образом, при прямом внутрисегментном переходе процессор вычисляет новый адрес как:
IP_new = IP_current + 2 + displacement
(для короткого перехода, где 2 — длина команды).

Такое решение повышает гибкость и переносимость машинного кода, позволяя перемещать блоки программы без пересчёта всех переходов.

\section{Каково различие между длинным и коротким прямым переходом?}

Команды прямого перехода (JMP, JE, JNE, JG, JL и др.) могут быть короткими (short) или длинными (near). Разница между ними определяется диапазоном адресов, на который можно перейти, и количеством байтов, занимаемых командой в памяти.

Короткий (short) переход используется, когда целевая команда находится на расстоянии от −128 до +127 байт от текущей. В этом случае в машинном коде сохраняется только 1-байтовое смещение, а сама команда занимает всего 2 байта (код операции + смещение).
Преимущество короткого перехода — компактность и высокая скорость выполнения. Недостаток — ограниченная дальность.

Длинный (near) переход позволяет перемещаться на любое расстояние в пределах текущего сегмента (до 64 Кбайт в реальном режиме). Здесь смещение занимает 16 или 32 бита, а команда — 3–5 байт. Такой переход используется, если цель находится дальше, чем допускает короткий формат.

Существуют также дальние (far) переходы, которые изменяют не только смещение (IP/EIP), но и сегментный регистр CS. Они используются для перехода между сегментами кода и занимают больше байтов (5 в 16-битном режиме).

Таким образом, различие между коротким и длинным переходом состоит в:

Размере смещения (1 байт против 2/4 байт);

Диапазоне перехода (±128 байт против всего сегмента);

Объёме занимаемой памяти;

Скорости выполнения — короткие переходы немного быстрее.

Компилятор и ассемблер TASM обычно выбирают короткий переход автоматически, если адрес цели попадает в допустимый диапазон. Если нет — применяется длинный. Такое различие позволяет одновременно сохранять компактность программы и обеспечивать возможность перехода на любой адрес внутри сегмента.

\endinput
