\chapter{Пересылка и преобразование формата данных}
\begin{itemize}
\item Какими командами можно расширить однобайтное значение до двухбайтного?
\item Какими командами можно расширить двухбайтный код до 4-х байтного?
\item Какие два значения являются для процессора программной <<координатой>> байта в пространстве физической памяти при сегментной адресации?
\item Что означает <<косвенная адресация>> операнда в памяти? Какие варианты косвенной адресации возможны?
\item Перечислите имена 8-разрядных, 16-разрядных и 32-разрядных регистров процессора x386.
\end{itemize}

\section{Какими командами можно расширить однобайтное значение до двухбайтного?}

При работе с языком ассемблера TASM и процессорами архитектуры x86 одной из базовых задач является приведение чисел меньшей разрядности к большей. Это необходимо потому, что арифметические и логические операции в процессоре выполняются не только над 8-битными, но и над 16- или 32-битными регистрами, а операнды разных размеров должны быть корректно согласованы. Примером является ситуация, когда в программе имеется переменная, хранящаяся в одном байте (8 бит), но требуется использовать её в арифметических операциях вместе с другими числами, представленными в двух байтах (16 бит)(). Чтобы выполнить такие действия, нужно расширить значение хранящееся, в формате малой разрядности, до формата большей разрядности.

Существует два основных способа расширения чисел: знаковое расширение и беззнаковое расширение. При знаковом расширении важно сохранить правильное значение числа с учётом его знака. В архитектуре x86 отрицательные числа хранятся в формате дополнительного кода, а значит, если старший бит формата равен 1, то число можно воспринимать как отрицательное. При знаковом расширении процессор копирует этот старший бит во все старшие разряды нового регистра, чтобы сохранить числовое значение. Например, если в 8-битном регистре AL хранится число 11111111 (−1), то при расширении до AX получится 11111111 11111111 (−1 в 16-битном представлении). Если бы такое расширение выполнялось как беззнаковое, то мы получили бы значение 00000000 11111111, которое соответствует уже не −1, а +255. Таким образом, знаковое расширение гарантирует корректность результата при работе с числами, у которых учитывается знак.

Для выполнения знакового расширения в архитектуре процессоров 8086/80286/80386 предусмотрена специальная команда CBW (Convert Byte to Word). Она автоматически преобразует содержимое младшего 8-битного регистра AL в 16-битное значение AX, копируя бит знака во все старшие разряды. Эта операция является очень удобной и выполняется за один такт, что делает её предпочтительной при арифметических вычислениях. В более поздних процессорах (начиная с 80386) была добавлена команда MOVSX (Move with Sign-Extend), которая также позволяет скопировать 8-битное значение в 16-битный или 32-битный регистр с сохранением знака, также позволяет знаково скопировать 16-битное значение в 32-битный регистр.

Второй вариант расширения — это беззнаковое расширение, которое осуществляется путём заполнения новых разрядов нулями. Такой подход применяется тогда, когда число хранится в виде беззнакового целого, например, используется как код символа, индекс массива или маска. В этом случае старшие разряды заполняются нулями, и значение числа остаётся тем же самым. Для выполнения этого действия в архитектуре x86 начиная с процессора 80386 была предусмотрена команда MOVZX (Move with Zero-Extend), которая позволяет перенести содержимое младшего регистра в старший с добавлением нулей. Например, если в AL хранится число 11111111 (255), то после выполнения MOVZX AX, AL результат будет 00000000 11111111, то есть 255 в 16-битной форме.

Таким образом, выбор между MOVSX и MOVZX зависит от того, как именно интерпретируется число: как знаковое или беззнаковое. Если программист работает с математическими величинами, где возможны отрицательные значения, нужно использовать знаковое расширение. Если же обрабатываются коды символов, элементы таблиц или иные значения, которые по смыслу не могут быть отрицательными, следует использовать беззнаковое расширение.

Важно отметить, что в реальных программах такие преобразования встречаются постоянно. Например, при считывании символа из файла или клавиатуры результат хранится в одном байте, но при последующей обработке этот символ нужно использовать как часть выражений, где участвуют 16-битные регистры. Без корректного расширения вычисления привели бы к искажению результатов. Поэтому команды MOVSX и MOVZX можно рассматривать как базовые инструменты для работы с данными в TASM.

В заключение можно сказать, что расширение значений — это фундаментальная операция в ассемблере. Она отражает особенности архитектуры x86 и тесно связана с внутренним устройством процессора, в частности с представлением чисел и системой команд. В TASM программисту предоставляется возможность явно управлять типом расширения, что делает программы более гибкими и позволяет эффективно работать как с целыми числами со знаком, так и с беззнаковыми данными.

\section{Какими командами можно расширить двухбайтный код до 4-х байтного?}

При работе с ассемблером TASM и архитектурой процессоров семейства x86 программист часто сталкивается с задачей обработки данных разной разрядности. Если число хранится в двух байтах, то есть в формате слова, 16-битное представление, и требуется использовать его в более широком регистре, например, 32-битном регистре, необходимо выполнить расширение исходного 16-битного кода. Как и в случае с преобразованием из 8 бит в 16 бит, различают два вида расширения: знаковое и незнаковое.

Знаковое расширение используется для чисел со знаком, представленных в формате дополнительного кода. В таком случае старший бит 16-битного числа (бит знака) копируется во все старшие разряды 32-битного регистра. Благодаря этому сохраняется корректное числовое значение. Например, если в AX хранится число 11111111 11111111 (−1 в 16-битном представлении), то после знакового расширения до регистра EAX мы получим 11111111 11111111 11111111 11111111, то есть −1 в 32-битной форме. Если бы расширение было выполнено нулями, то результат оказался бы равен 65535, что уже полностью искажает исходное значение.

Для выполнения знакового расширения в процессоре 80386 и выше существует команда CWD (Convert Word to Doubleword). Она преобразует содержимое регистра AX в значение DX:AX, где DX получает копию знакового бита. Таким образом, пара регистров DX:AX образует 32-битное число. Однако в более поздних процессорах (80386 и выше) появилась более удобная команда CWDE (Convert Word to Doubleword in EAX), которая копирует 16-битное значение AX в 32-битный регистр EAX с автоматическим распространением знака. Благодаря этой команде работа с расширением стала проще и быстрее.

Для беззнаковых чисел применяется другой принцип: старшие разряды заполняются нулями. Этот метод известен как нулевое расширение. Он используется в тех случаях, когда число всегда положительно. Для выполнения такого преобразования в архитектуре 80386 и выше существует команда MOVZX (Move with Zero-Extend). Она позволяет скопировать значение AX в EAX с добавлением нулей в старшую часть. Например, если в AX хранится число 65535 (11111111 11111111), то после MOVZX результатом в EAX будет 00000000 00000000 11111111 11111111, то есть то же самое число в 32-битной форме.

Таким образом, выбор между знаковым и незнаковым расширением определяется контекстом использования кода числа. Если оно представляет математическую величину, где возможны отрицательные значения, применяется CWDE, CWD или MOVSX. Если же речь идёт о кодах символов, адресах или других беззнаковых данных, используется MOVZX.

Практическая значимость таких операций огромна. Во-первых, они позволяют обрабатывать данные разных форматов в рамках одной программы. Во-вторых, правильный выбор метода расширения напрямую влияет на корректность вычислений. Ошибка в выборе, например, использование нулевого расширения там, где нужно знаковое, может привести к неправильным результатам и логическим сбоям в программе.

Таким образом, команды CWD, CWDE, MOVZX и MOVSX являются ключевыми для работы с числами при расширении из 16 бит в 32 бита. Они отражают развитие архитектуры процессоров от 16-битных моделей (8086/80286) к полноценным 32-битным (80386 и выше). В TASM эти команды используются очень часто, так как большинство современных программных задач требует работы с данными переменной разрядности.


\section{Какие два значения являются для процессора программной <<координатой>> байта в пространстве физической памяти при сегментной адресации?}

Архитектура процессоров x86 основана на принципе сегментной организации памяти. В отличие от простого линейного подхода, где каждый байт имеет уникальный адрес, сегментная модель предполагает, что физический адрес байта вычисляется как комбинация двух величин: сегмента и смещения (offset). Именно эти два значения образуют то, что можно назвать «координатой» байта в пространстве физической памяти.

Первое значение — это сегментный адрес, который хранится в специальном сегментном регистре. Существует несколько сегментных регистров: CS (кодовый сегмент), DS (сегмент данных), SS (сегмент стека), ES, FS, GS (дополнительные сегменты). Каждый из них указывает на начало определённой области памяти, с которой работает программа. Например, CS определяет, где находится исполняемый код, DS — данные, а SS — стек.

Второе значение — это смещение (offset), то есть расстояние в байтах от начала сегмента до требуемого элемента памяти. Разрядность смещения зависит от объёма сегмента. Так как память в вычислительных системах с архитектурой фон Неймона определяется ячейками с бинарынм состоянием, то адресное пространство сегмента определяется через поле Галуа GF=2. Таким образом объём памяти в сегменте кратен степени двойки и представляет собой степень вида 2^N, соответственно смещение имеет формат N. Смещение задаётся  и вычисляется с помощью регистров общего назначения (BX, SI, DI, BP) или непосредственного значения. В ассемблере TASM смещения часто используются в косвенных и индексных адресациях.
Таким образом, для процессора каждый байт в памяти определяется двумя значениями: содержимым сегментного регистра и величиной смещения. Это и является его «координатой» в пространстве памяти.

Такой подход имеет ряд преимуществ. Во-первых, он позволяет программе работать с адресами, не выходящими за пределы 64 КБ, даже если физическая память значительно больше. Во-вторых, сегментная организация облегчает многозадачность и защиту памяти: можно выделять разные сегменты для разных частей программы и ограничивать доступ к ним.

С другой стороны, сегментная модель имеет и недостатки. Сложность вычисления физического адреса (сегмент * 16 + смещение) делает архитектуру менее прозрачной. Кроме того, при программировании на ассемблере нужно всегда помнить о том, какой сегментный регистр используется по умолчанию и как изменяется смещение.

Таким образом, ответ на вопрос заключается в том, что координатой байта при сегментной адресации являются сегментный адрес и смещение. Именно они вместе определяют физическое расположение данных в памяти, а сегментная модель памяти является одной из ключевых особенностей архитектуры x86.

\section{Что означает <<косвенная адресация>> операнда в памяти? Какие варианты косвенной адресации возможны?}

Косвенная адресация — это один из способов обращения к операндам в ассемблере, при котором команда не содержит непосредственно адрес данных, а указывает на регистр или комбинацию регистров, хранящих этот адрес. Иными словами, команда указывает не на сам операнд, а на «указатель» к нему. Такой метод используется для более гибкой работы с памятью, особенно когда данные расположены в массивах, таблицах или стеке.

Простейший пример косвенной адресации — это использование регистра BX. Если написать команду MOV AX, [BX], процессор возьмёт значение из памяти, по умолчанию в сегменте DS, по адресу, хранящемуся в регистре BX. Таким образом, BX играет роль указателя на элемент памяти.

Косвенная адресация может быть разной сложности. Помимо использования одного регистра, возможны комбинации базовых и индексных регистров. Базовыми регистрами считаются BX и BP, индексными — SI и DI. Дополнительно можно использовать смещения (константы).

Возможные варианты косвенной адресации в архитектуре x86:

[BX], [BP], [SI], [DI] — простая косвенная адресация.

[BX+SI], [BX+DI], [BP+SI], [BP+DI] — базово-индексная адресация.

[BX+смещение], [BP+смещение], [SI+смещение], [DI+смещение] — косвенная адресация с постоянным смещением.

[BX+SI+смещение] и аналогичные варианты — базово-индексная адресация со смещением.

Каждый из этих способов удобен в определённых ситуациях. Например, SI и DI часто используются при обработке строк и массивов, так как они могут автоматически увеличиваться или уменьшаться при выполнении команд REP MOVSB или REP SCASB. Использование BP удобно для работы со стеком и локальными переменными в процедурах.

Главное достоинство косвенной адресации заключается в её универсальности. Она позволяет строить гибкие структуры данных, работать с массивами переменной длины и обрабатывать динамические данные. В языке высокого уровня такие операции скрыты за синтаксисом массивов и указателей, но в ассемблере программист должен явно задавать, каким образом вычисляется адрес.

Таким образом, косвенная адресация операнда в памяти — это использование регистров и/или их комбинаций для вычисления адреса данных. Возможные варианты включают простую регистровую, базово-индексную, с постоянным смещением и с комбинацией регистра и смещения. Этот механизм является одним из важнейших в TASM и архитектуре x86.

\section {Перечислите имена 8-разрядных, 16-разрядных и 32-разрядных регистров процессора x386.}

Процессоры семейства x86 имеют развитую систему регистров, которые служат для хранения данных, адресов и управляющей информации. Каждый регистр имеет своё назначение и может использоваться как в общем виде, так и в узкоспециализированных командах. В TASM программисту необходимо хорошо знать структуру регистров, так как от этого зависит корректность написания программы.

8-разрядные регистры

Восьмиразрядные регистры представляют собой младшие и старшие части 16-битных регистров AX, BX, CX и DX.

AL (младшие 8 бит AX), AH (старшие 8 бит AX).

BL, BH — части BX.

CL, CH — части CX.

DL, DH — части DX.

Эти регистры применяются для хранения байтовых данных, работы с символами, побитовыми операциями и арифметикой над малыми величинами.

16-разрядные регистры

AX (аккумулятор) — основной регистр для арифметики и ввода-вывода.

BX (базовый регистр) — часто используется для адресации.

CX (счётчик) — применяется в циклах и сдвигах.

DX (регистр данных) — участвует в операциях умножения и деления.

SI (Source Index) — индекс источника для операций со строками.

DI (Destination Index) — индекс приёмника.

BP (Base Pointer) — базовый указатель, часто используется для доступа к локальным переменным.

SP (Stack Pointer) — указатель стека.

К ним добавляются сегментные регистры: CS, DS, SS, ES, FS, GS. Они определяют границы сегментов кода, данных и стека.

32-разрядные регистры (введены в 80386)

EAX, EBX, ECX, EDX — расширенные версии 16-битных регистров.

ESI, EDI, EBP, ESP — расширенные версии индексных и указательных регистров.

EIP — указатель команд, хранит адрес следующей инструкции.

EFLAGS — регистр флагов, хранящий результаты операций и управляющие биты.

Знание структуры регистров крайне важно, потому что многие команды TASM жестко привязаны к конкретным регистрами. Например, команда MUL при умножении всегда использует AX или EAX. Команды циклов ориентируются на CX или ECX. Сегментные регистры также используются по умолчанию (например, при косвенной адресации через BX или SI по умолчанию применяется DS).

Таким образом, регистры процессора x386 делятся на три группы: 8-разрядные (AH, AL, BH и др.), 16-разрядные (AX, BX, CX, DX, SI, DI и др.) и 32-разрядные (EAX, EBX, ECX и др.). Каждая из этих групп имеет своё назначение, и эффективное владение ими является основой программирования на TASM.

\endinput
