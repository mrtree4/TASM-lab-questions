\chapter{Процедуры}
\begin{itemize}
\item С какой целью создают подпрограммы (процедуры) при разработке программной логики?
\item Как задавать входные и где размещать выходные параметры для процедуры в ассемблерной программе?
\item Какая команда должна быть последней исполняемой в процедуре?
\item Что такое макрокоманда транслятора?
\item Для чего создают макрокоманды? Чем макрокоманда отличается от процедуры?
\end{itemize}

\section{С какой целью создают подпрограммы (процедуры) при разработке программной логики?}

Подпрограммы, или процедуры, создаются в процессе разработки программ для структурирования кода, повторного использования логики и упрощения сопровождения программы. Основная идея заключается в том, чтобы выделить повторяющиеся участки кода в отдельные именованные блоки, которые можно вызвать из разных частей программы. Это повышает читаемость, сокращает размер исходного текста и делает его более удобным для модификации и отладки.

При написании больших программ на ассемблере код может достигать сотен строк. Если один и тот же алгоритм — например, вывод символа на экран, копирование данных из памяти или арифметическая операция — выполняется несколько раз, гораздо рациональнее вынести его в отдельную процедуру. Тогда достаточно один раз описать логику, а при необходимости просто вызывать её по имени.

Процедуры также позволяют реализовать модульный принцип построения программ, когда каждая часть отвечает за конкретную задачу. Это облегчает тестирование и повторное использование готовых решений. Кроме того, процедуры помогают экономить память: вместо многократного дублирования одних и тех же команд в разных частях программы хранится только один экземпляр кода.

Таким образом, создание подпрограмм в TASM и других ассемблерах служит трём главным целям:

Структурирование — деление программы на логические блоки.

Унификация — исключение повторяющегося кода.

Модульность и повторное использование — возможность применять готовые процедуры в других проектах.

Благодаря подпрограммам даже низкоуровневый язык, как ассемблер, приобретает свойства структурного программирования и становится значительно удобнее для разработки крупных систем.

\section{Как задавать входные и где размещать выходные параметры для процедуры в ассемблерной программе?}

Входные и выходные параметры — это данные, которые передаются в процедуру и возвращаются из неё. В ассемблерных программах существует несколько способов организации параметров, и выбор зависит от типа задачи и архитектуры процессора.

Входные параметры

Обычно входные параметры передаются одним из следующих способов:

Через регистры — самый быстрый способ, когда аргументы заносятся в регистры перед вызовом процедуры. Например, значение передаётся в AX, BX, CX и т. д. Это экономит время, но ограничено количеством доступных регистров.

Через стек — универсальный способ, когда параметры помещаются в стек с помощью команды PUSH перед вызовом процедуры. Внутри процедуры их можно прочитать через регистр BP.

Через область памяти (глобальные переменные) — когда процедура обращается к заранее известным адресам данных в памяти. Это удобно, если объём данных большой.

Выходные параметры

Результаты работы процедуры могут возвращаться следующими способами:

Через регистр AX (или другие регистры) — стандартный способ возврата результата вычисления.

Через память — если результат представляет собой массив, структуру или несколько значений.

Через стек — если нужно вернуть несколько значений, их можно поместить обратно в стек перед возвратом.

Таким образом, входные параметры задаются через регистры, стек или память, а выходные обычно размещаются в регистрах или по известным адресам памяти. Такой подход делает процедуры универсальными и позволяет вызывать их из разных частей программы без повторного описания логики.

\section{Какая команда должна быть последней исполняемой в процедуре?}

Последней исполняемой командой в любой процедуре должна быть RET — от английского return, что означает «возврат».

Команда RET выполняет обратный переход из подпрограммы в то место, откуда она была вызвана. При этом процессор извлекает из стека сохранённый адрес возврата, который был помещён туда во время вызова процедуры командой CALL. После выполнения RET управление передаётся на следующую инструкцию в основной программе.

Принцип работы следующий:

Когда выполняется команда CALL, процессор автоматически помещает в стек адрес возврата (адрес следующей инструкции после CALL).

После завершения подпрограммы команда RET извлекает этот адрес из стека и передаёт управление обратно.

Кроме обычной команды RET, существует вариант RET n, где n — количество байтов, которые нужно удалить из стека после возврата. Это используется в процедурах, где параметры передаются через стек.

Таким образом, команда RET является обязательной для правильного завершения подпрограммы. Без неё процессор не сможет корректно вернуть управление, что приведёт к нарушению логики программы или ошибкам выполнения. RET — это аналог оператора return в языках высокого уровня, но в ассемблере она управляет именно адресами в стеке.

\section{Что такое макрокоманда транслятора?}

Макрокоманда (макрос) — это конструкция ассемблера, которая позволяет определять последовательность команд, выполняющих определённое действие, под одним именем. При трансляции программы макрокоманда не исполняется как процедура, а разворачивается транслятором в реальный набор инструкций.

Иными словами, макрокоманда — это текстовая подстановка, выполняемая ещё на этапе трансляции, до запуска программы. При каждом использовании макроса транслятор подставляет вместо него определённую последовательность инструкций.

Макрокоманды создаются с помощью директивы MACRO, а завершаются директивой ENDM. Например, если определена макрокоманда CLEAR_REGS, при каждом её вызове в программе транслятор заменит имя на набор команд, которые она описывает.

Преимущество макрокоманд заключается в том, что они позволяют сократить количество повторяющегося кода и сделать программу более наглядной, при этом не создавая затрат на вызовы подпрограмм. Однако, поскольку при каждом использовании макроса его тело копируется в программу, это увеличивает итоговый размер машинного кода.

Таким образом, макрокоманда — это механизм транслятора, а не процессора. Она служит для упрощения написания и чтения программы, автоматизируя создание однотипных участков кода.

\section{Для чего создают макрокоманды? Чем макрокоманда отличается от процедуры?}

Макрокоманды создаются для автоматизации повторяющихся фрагментов кода, упрощения программирования и повышения читаемости исходного текста. Их основное назначение — позволить программисту один раз определить шаблон, который затем можно многократно использовать без написания одинаковых инструкций вручную.

Например, если в программе часто нужно обнулять набор регистров или выполнять стандартную последовательность инициализации, можно определить макрокоманду, которая будет разворачиваться транслятором при каждом вызове.
Таким образом, макрокоманда — это инструмент компилятора (транслятора), а процедура — механизм исполнения на процессоре. Макросы удобны для коротких повторяющихся действий, а процедуры — для больших или универсальных алгоритмов, где важно сэкономить память.

Макрокоманды широко применяются в ассемблере TASM для описания типовых шаблонов операций, упрощения кода и ускорения разработки программ, не прибегая к сложным вызовам подпрограмм.

\endinput
