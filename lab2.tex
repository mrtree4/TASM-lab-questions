\chapter{Арифметические и логические операции}
\begin{itemize}
\item Чем отличается команда SBB от SUB?
\item Как выполняется команда CMP?
\item Как выполняется процессором команда NEG?
\item Каково различие между длинным и коротким прямым переходом?
\item Чем отличаются логические команды от арифметических команд?
\item Чем отличаются команды логического умножения AND и TEST?
\item Какой логической командой можно обнулить отдельные биты регистра или ячейки памяти?
\item Какой логической командой можно установить отдельные биты регистра или ячейки памяти в 1?
\item Какой логической командой можно инвертировать отдельные биты регистра или ячейки памяти?
\item В каких случаях с помощью команд сдвига можно выполнять умножение и деление?
\item Каковы особенности выполнения операций обычного, арифметического и циклического сдвига?
\end{itemize}

\section{Чем отличается команда SBB от SUB?}

В архитектуре процессоров семейства x86 и языке ассемблера TASM обе команды — SBB и SUB — предназначены для выполнения операции вычитания.
Однако их различие заключается в том, каким образом они учитывают флаг переноса (CF, Carry Flag), который хранится в регистре флагов процессора и отражает результат предыдущей арифметической операции.

Команда SUB (Subtract) выполняет простое вычитание второго операнда из первого без учёта каких-либо предыдущих действий.
Например, при выполнении SUB AX, BX из содержимого регистра AX вычитается значение BX, а результат записывается обратно в AX.
После выполнения команда изменяет флаги процессора, такие как флаг нуля (ZF), знака (SF), переполнения (OF), переноса (CF) и других.
Однако SUB не использует значение флага CF при вычислении — она его только обновляет в зависимости от результата вычитания.

Команда SBB (Subtract with Borrow), напротив, предназначена для вычитания с учётом возможного займа из предыдущей операции.
При её выполнении из первого операнда вычитается не только значение второго операнда, но и значение флага CF.
То есть фактически выполняется операция: A ← A − B − CF.

Если флаг CF равен 1 (что означает, что в предыдущем вычитании был «заём»), то из результата дополнительно вычитается единица.

Это различие имеет принципиальное значение при выполнении многобайтовых и многоразрядных вычитаний.
Например, если нужно вычесть одно 32-битное число из другого в 16-битной архитектуре, операция делится на два этапа: сначала вычитаются младшие 16 бит с помощью SUB, затем старшие 16 бит — с помощью SBB, которая учитывает возможный «заём» из младшей части.
Таким образом обеспечивается корректное арифметическое поведение при работе с числами, превышающими разрядность регистра.

% Про операции с длинными числами -- понятно. Но как это влияет на алгоритмы шифрования и арифметику с плавающей точкой?
Команда SBB особенно важна при реализации операций с длинными целыми числами, алгоритмов шифрования, арифметики с плавающей точкой в программном виде и других ситуациях, где требуется точное управление переносами между частями числа.

Таким образом, основное различие между командами SUB и SBB заключается в учёте флага CF.
SUB выполняет простое вычитание без учёта предыдущих операций, тогда как SBB используется для последовательных вычитаний, когда необходимо учитывать перенос (или заём) из предыдущего разряда.
Это различие делает SBB ключевой частью всех алгоритмов работы с числами большей разрядности, чем может вместить регистр процессора.

\section{Как выполняется команда CMP}

Команда CMP (Compare) — одна из базовых инструкций языка ассемблера TASM, предназначенная для сравнения двух операндов.
Однако в действительности команда не выполняет непосредственного сравнения в логическом смысле, а реализуется как операция вычитания без сохранения результата.
Это означает, что CMP вычитает второй операнд из первого, но не изменяет ни один из них.
Её основная цель — обновить флаги процессора в зависимости от результата этой операции, чтобы на их основе можно было выполнить условные переходы.
Фактически выполнение CMP можно представить как: A − B, но результат этого вычитания не сохраняется в A.
Вместо этого процессор обновляет флаги:
ZF (Zero Flag) — устанавливается, если результат равен нулю (то есть операнды равны).
SF (Sign Flag) — отражает знак результата (если результат отрицательный, SF = 1).
CF (Carry Flag) — показывает, был ли «заём» при вычитании (если A < B, CF = 1).
OF (Overflow Flag) — устанавливается при арифметическом переполнении.

% Сопоставить какие конкретно флаги используется для каждого из перечисленных переходов и объяснить почему
После выполнения CMP программа обычно использует результаты сравнения в командах условного перехода, таких как JE (Jump if Equal), JNE (Jump if Not Equal), JL (Jump if Less), JG (Jump if Greater) и других.
Таким образом, CMP и последующий условный переход образуют вместе аналог оператора if в языках высокого уровня.

% Безопасной -- не тот термин. Тут речь не о безопасности, а о нарушении логики работы алгоритма
Команда CMP не изменяет содержимого операндов, что делает её безопасной для использования в циклах, проверках и логических ветвлениях. 
Она может применяться как для чисел со знаком, так и без знака.

% Может быть наоборот команды переходов определяются тем, какие числа сравниваются?
Тип сравнения определяется тем, какие именно команды перехода используются после неё: например, JA/JB (above/below) — для беззнаковых чисел, JG/JL — для знаковых.
Таким образом, CMP выполняет вычитание для определения отношения между двумя операндами и изменяет флаги процессора, не изменяя при этом сами операнды.
Это делает её центральным инструментом для организации ветвлений, циклов и проверок в программах на ассемблере.

\section{Как выполняется процессором команда NEG?}

Команда NEG (Negate) предназначена для получения отрицательного значения операнда, то есть вычисления его арифметического отрицания.
Она реализует операцию, эквивалентную вычитанию операнда из нуля:
Операнд ← 0 − Операнд.
При выполнении этой инструкции процессор инвертирует все биты числа и добавляет единицу (что соответствует операции получения дополнительного кода).
Таким образом, если исходное значение было положительным, результат становится отрицательным, и наоборот.
Например, если значение было 5, после NEG оно становится −5; если −3 — становится 3.
В процессе выполнения NEG изменяются флаги процессора:
CF (Carry Flag) устанавливается, если операнд был отличен от нуля (так как происходит заём при вычитании).
ZF (Zero Flag) устанавливается, если результат равен нулю (например, при NEG 0).
SF (Sign Flag) отражает знак результата.
OF (Overflow Flag) устанавливается при переполнении (например, при попытке изменить знак числа с минимальным отрицательным значением, которое не имеет положительного аналога).
Команда NEG часто используется для изменения направления арифметических вычислений, при реализации операций вычитания через сложение, а также в операциях, связанных с обработкой знаковых данных.

% Зачем?
Например, если нужно заменить SUB AX, BX на эквивалентную последовательность, можно выполнить NEG BX и затем ADD AX, BX.
Таким образом, команда NEG выполняет инвертирование знака числа и реализуется как операция вычитания из нуля.
Она изменяет флаги процессора и является основным средством для получения противоположных по знаку значений в ассемблерных программах.

% Не раскрыт вопрос назначения данной команды. Почему вместо NEG просто не использовать SUB с нулём?

\section{Каково различие между длинным и коротким прямым переходом?}

В ассемблере TASM, как и в архитектуре x86, команды переходов позволяют изменять последовательность выполнения программы.
Существует несколько разновидностей переходов, в том числе короткие (short) и длинные (near/far).
Их различие связано с тем, как вычисляется адрес перехода и какое расстояние между командами допускается.
Короткий переход (short jump) используется, когда целевая инструкция находится в пределах −128…+127 байт от текущего адреса.
Это наиболее экономичный тип перехода, поскольку команда занимает всего 2 байта: один — на код операции, второй — на смещение относительно текущего адреса.
Короткие переходы применяются в пределах небольших участков программы, например, внутри циклов или условных блоков.
Длинный (near) переход позволяет перейти к любой команде в пределах текущего сегмента.
В этом случае смещение указывается полностью (16 бит для реального режима, 32 бита для защищённого).
Команда занимает больше места — 3 байта (в 16-битном режиме) или 5 байт (в 32-битном).

% Что значит "перейти в другой сегмент памяти"? Мы же осуществляем здесь переход на команду для дальнейшего исполнения. Команды у нас в кодовом сегменте. А кодовый сегмент один -- CS. Так куда же мы тогда переходим и что же тогда получается?
Существует также дальний (far) переход, который используется для перехода в другой сегмент памяти.
Он содержит не только смещение, но и значение сегмента, поэтому команда занимает 5 байт в 16-битном режиме (2 байта на смещение, 2 — на сегмент, плюс код операции).
Таким образом, различие между коротким и длинным переходом заключается в размере адресного смещения и дальности, на которую возможен переход.
Короткий — наиболее экономичный, но ограничен по диапазону.
Длинный — универсальный в пределах сегмента, а дальний — позволяет переходить между сегментами программы.

\section{Чем отличаются логические команды от арифметических команд?}

Логические и арифметические команды в языке ассемблера TASM выполняют разные типы операций над двоичными данными, хотя внешне они могут выглядеть схожими.
Основное различие между ними заключается в том, что именно они делают с битами данных и какие флаги процессора изменяют.
Арифметические команды (например, ADD, SUB, INC, DEC, MUL, DIV, NEG, ADC, SBB) выполняют математические операции — сложение, вычитание, умножение, деление, инкремент, декремент и т.д.
Эти команды интерпретируют данные как числа (со знаком или без) и учитывают переносы и переполнения.
При их выполнении изменяются флаги, связанные с результатом вычислений:
CF (Carry Flag) — устанавливается, если при сложении или вычитании произошёл перенос или заём;
OF (Overflow Flag) — сигнализирует о переполнении при операциях со знаковыми числами;
ZF (Zero Flag) — показывает, равен ли результат нулю;
SF (Sign Flag) — определяет знак результата.
Логические команды (AND, OR, XOR, NOT, TEST) рассматривают данные не как числа, а как набор отдельных битов.
Они выполняют операции булевой логики: конъюнкцию, дизъюнкцию, исключающее ИЛИ и отрицание.

% На счёт флага CF сильно сомневаюсь...
Эти операции не связаны с понятием переноса, поэтому CF и OF всегда сбрасываются в 0, а остальные флаги (ZF, SF, PF) устанавливаются в зависимости от результата.
Таким образом, логические команды используются для побитовой обработки данных — включения или обнуления отдельных битов, проверки флагов, маскирования и подготовки данных для последующих арифметических или управляющих операций.
Арифметические же команды — для изменения численных значений и выполнения вычислений.
Проще говоря, арифметические инструкции оперируют значениями, а логические — их структурой.
Именно благодаря такому разделению ассемблер позволяет эффективно управлять не только данными, но и самими битами, из которых они состоят.

% К какому типу команд относятся сдвиги?

\section{Чем отличаются команды логического умножения AND и TEST?}

Команды AND и TEST в TASM действительно похожи, поскольку обе выполняют операцию побитового логического И (AND).
Различие между ними заключается не в самой логике вычислений, а в том, что происходит с результатом.
Команда AND выполняет логическое умножение (побитовое И) двух операндов и сохраняет результат в первом операнде.
Например:
AND AX, 0FFh — в результате в AX останется значение, у которого обнулены все старшие биты.
Эта операция используется для очистки, маскирования или выделения определённых битов.
После выполнения команда изменяет флаги:
ZF — устанавливается, если результат равен нулю;
SF — отражает знак результата;
PF — показывает чётность количества единиц в результате;
CF и OF всегда сбрасываются в 0.
Команда TEST, напротив, выполняет такое же побитовое И, но результат нигде не сохраняет.
Она предназначена исключительно для проверки определённых битов без изменения данных.
Например:
TEST AL, 1 — проверяет, установлен ли младший бит регистра AL.
Если результат нулевой, значит бит равен 0; иначе — 1.
Таким образом, команда TEST — это безопасный способ «заглянуть» в данные без их изменения, а AND — инструмент для реального изменения содержимого регистра или ячейки памяти.

\section{ Какой логической командой можно обнулить отдельные биты регистра или ячейки памяти?}

Для обнуления отдельных битов регистра или ячейки памяти используется команда AND.
Логическое умножение (AND) выполняется по битам, и в результате каждый бит становится равным 1 только если оба соответствующих бита операндов равны 1.
Если один из них равен 0, то результатом будет 0.
Поэтому если нужно обнулить определённые биты, применяется маска, в которой те биты, что должны остаться, устанавливаются в 1, а те, которые нужно сбросить, устанавливаются в 0.
Это свойство делает команду AND одним из ключевых инструментов при низкоуровневой обработке данных, особенно в драйверах, микроконтроллерах, обработке флагов и кодировании состояний устройств.

% Почему логическое И позволяет сбрасывать в ноль отдельные биты? Как так получается? Благодаря чему? 

\section{Какой логической командой можно установить отдельные биты регистра или ячейки памяти в 1?}

Для установки отдельных битов в единицу используется команда OR.
Она выполняет побитовую дизъюнкцию (логическое ИЛИ), при которой бит результата равен 1, если хотя бы один из соответствующих битов операндов равен 1.
Если нужно установить конкретные биты, используется маска, в которой биты, подлежащие установке, равны 1, а остальные — 0.
Команда OR часто используется для задания флагов, включения режимов работы устройств, формирования управляющих байтов и настройки параметров, когда требуется установить конкретные разряды, не влияя на другие.

% Аналогичный вопрос - откуда такое свойство?

\section{Какой логической командой можно инвертировать отдельные биты регистра или ячейки памяти?}

Для инверсии битов используется команда NOT.
Она выполняет побитовое отрицание, т.е.
заменяет все нули на единицы и все единицы на нули.
Если исходное значение было 10101010b, то после выполнения команда даст 01010101b
Инструкция NOT не изменяет никаких флагов процессора, что отличает её от большинства других логических операций.
Она часто применяется при операциях с масками, при побитовом кодировании и в логике, где требуется обращение всех битов, например, при формировании обратных кодов или вычислении отрицаний булевых выражений.

% Примеры оптимизации логических выражений командой NOT

\section{В каких случаях с помощью команд сдвига можно выполнять умножение и деление?}

% К какому классу относятся данные сдвиги?
Команды сдвига (SHL, SHR, SAL, SAR) позволяют не только перемещать биты влево или вправо, но и выполнять эффективные операции умножения и деления на степени числа 2.
Если выполнить сдвиг влево (SHL или SAL), каждый бит числа перемещается на один разряд влево, а младший заполняется нулём.
Это эквивалентно умножению числа на 2.
Если сдвинуть на 2 позиции — умножаем на 4, на 3 — на 8 и так далее.
Например:
SHL AX, 1 — умножает содержимое регистра AX на 2.
Аналогично, сдвиг вправо (SHR) делит беззнаковое число на 2, а SAR — делит знаковое число, сохраняя его знак.
Эти операции выполняются значительно быстрее, чем обычное умножение или деление, и используются в оптимизированных программах, где важна производительность — например, при графических вычислениях, обработке массивов или в системном программировании.

% Допустим, нужно произвести умножение на число 1743202415431040. Как это можно сделать и на сколько разрядов нужен будет сдвиг?

\section{Каковы особенности выполнения операций обычного, арифметического и циклического сдвига?}

В архитектуре x86 существует три основных типа сдвига: логический, арифметический и циклический.
Все они перемещают биты, но делают это по-разному, в зависимости от того, как обращаются со знаковыми и крайними битами.
Логический сдвиг (SHL, SHR) — сдвигает биты влево или вправо, а освободившиеся позиции заполняет нулями.
Он подходит для работы с беззнаковыми числами.
Арифметический сдвиг (SAL, SAR) — применяется к числам со знаком.
При сдвиге вправо сохраняется старший (знаковый) бит, что позволяет сохранять знак числа.
Например, при делении отрицательных чисел результат остаётся отрицательным.
Циклический сдвиг (ROL, ROR, RCL, RCR) — переносит биты, «выпавшие» с одного края, на противоположный.
Это используется при криптографических преобразованиях, шифровании, побитовых операциях с ключами и контрольных суммах.
Циклические сдвиги бывают с участием флага переноса (RCL, RCR) и без него (ROL, ROR), что позволяет гибко управлять движением битов.
Таким образом, различие между типами сдвига заключается в том, как они обращаются с освободившимися битами и сохраняют ли знак числа.
Эти инструкции позволяют реализовывать целые классы математических, логических и криптографических операций без использования сложных арифметических команд.

\endinput
