\chapter{Форматы команд. Трансляция символической команды в код}
\begin{itemize}
\item Какова минимальная длина команды в байтах?
\item От чего зависит длина команды с операндами?
\item Что такое <<вторичный>> код операции? В формате каких команд он присутствует?
\item Приведите пример команды с максимальной длиной.
\end{itemize}

\section{Какова минимальная длина команды в байтах?}

Минимальная длина команды в архитектуре x86 (в частности, для процессоров, поддерживаемых TASM) составляет один байт. Это возможно в тех случаях, когда команда не имеет операндов и не требует дополнительных данных — например, когда она обозначает однозначное действие процессора.

Однобайтные команды — это, как правило, простейшие инструкции управления, флагов или работы с регистрами, не требующие обращения к памяти. Примеры таких инструкций включают:

CLC — сброс флага переноса;

STC — установка флага переноса;

NOP — операция «ничего не делать» (no operation);

RET — возврат из процедуры без параметров;

INT 3 — программное прерывание (отладка).

Каждая из этих команд кодируется одним байтом, в котором уже содержится весь код операции (opcode). Процессору не нужно считывать дополнительные байты для операндов, смещений или констант, так как они отсутствуют.

Таким образом, минимальная длина команды — 1 байт, и такие инструкции выполняются особенно быстро, поскольку процессору достаточно считать только один байт из памяти.

\section{От чего зависит длина команды с операндами?}

Длина команды с операндами в архитектуре x86 не является фиксированной и может изменяться от 1 до 15 байт. Она зависит от целого ряда факторов, связанных с типом команды, видом операндов и режимом адресации.

Основные факторы, влияющие на длину команды:

Наличие префиксов — префиксы могут добавлять от 1 до 4 байт в начале команды. Они задают, например, сегмент, размер операндов или направление повторения (например, REP, LOCK, SEG).

Основной код операции (opcode) — занимает обычно 1 байт, но для некоторых команд может состоять из двух (например, когда используется расширенный набор инструкций).

Модульно-регистровый байт (ModR/M) — добавляется, если команда использует регистры или адреса памяти в качестве операндов. Этот байт указывает, откуда берутся данные: из регистра или из памяти.

Байт масштабирования и индекса (SIB) — используется в 32-разрядных режимах при сложных формах адресации (например, [EAX + EBX*4 + 8]).

Смещение (displacement) — добавляется, если команда обращается к ячейке памяти со смещением (1, 2 или 4 байта в зависимости от режима).

Непосредственные данные (immediate value) — если команда содержит встроенную константу, её размер также увеличивает длину инструкции (1, 2 или 4 байта).

Таким образом, длина команды напрямую зависит от сложности адресации и числа операндов. Простейшие команды состоят из одного байта, а наиболее сложные, включающие несколько префиксов, смещений и непосредственных данных, могут достигать 15 байт.

Это свойство делает архитектуру x86 CISC (Complex Instruction Set Computer), то есть с переменной длиной команд, что обеспечивает гибкость, но усложняет декодирование инструкций процессором.


\section{Что такое <<вторичный>> код операции? В формате каких команд он присутствует?}

Вторичный код операции — это дополнительная часть машинного кода, уточняющая действие, определяемое основным кодом (opcode). Он используется в командах, где основной байт opcode не полностью определяет выполняемую операцию и требует дополнительного указания конкретного варианта через биты другого байта.

В архитектуре x86 вторичный код обычно содержится в ModR/M-байте, который имеет следующую структуру:

| Mod (2 бита) | Reg/Opcode (3 бита) | R/M (3 бита) |


Поле Reg/Opcode может использоваться не для обозначения регистра, а для задания вторичного кода операции. Это означает, что один и тот же основной код (opcode) может обозначать несколько разных инструкций, различающихся по полю Reg/Opcode.

Примером может служить команда с кодом 80h, которая используется для целого набора инструкций:

80 /0 — ADD (сложение);

80 /1 — OR (логическое «или»);

80 /2 — ADC (сложение с переносом);

80 /3 — SBB (вычитание с заёмом);

и т.д.

Здесь значение /0, /1, /2, /3 и т.д. — это и есть вторичный код операции, который определяет конкретное действие.

Таким образом, вторичный код операции присутствует в командах с полем ModR/M, когда один и тот же основной байт opcode используется для группы родственных инструкций. Этот подход позволяет экономить место в таблице кодов и делает систему кодирования более гибкой.


\section{Приведите пример команды с максимальной длиной.}

Максимальная длина команды в архитектуре x86 составляет 15 байт. Этот предел установлен архитектурно и поддерживается всеми современными процессорами Intel и AMD.

Такой максимальной длины команда достигает в случае, если она содержит:

несколько префиксов (например, сегментный, операндный и адресный);

основной opcode (1 или 2 байта);

байты ModR/M и SIB;

смещение (displacement);

непосредственное значение (immediate data).

Пример (в обобщённом виде):

REP FS ADD DWORD PTR [EAX+EBX*4+12345678h], 9ABCDEF0h

Эта инструкция может содержать:

префикс REP (1 байт);

префикс сегмента FS (1 байт);

основной код операции ADD (1 байт);

байт ModR/M (1 байт);

байт SIB (1 байт);

4-байтовое смещение;

4-байтовое непосредственное значение.

В итоге общая длина достигает 15 байт — предельного размера, разрешённого архитектурой.

Команды такой длины встречаются редко, обычно в сложных случаях адресации или при работе с большими непосредственными данными. В практических программах большинство инструкций занимают 2–6 байт.

Таким образом, команда с максимальной длиной — это инструкция, содержащая одновременно несколько префиксов, сложную адресацию и встроенные константы. Процессор корректно обрабатывает такие команды, но их использование замедляет декодирование и выполнение.

\endinput
